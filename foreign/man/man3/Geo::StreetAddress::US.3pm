.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "US 3"
.TH US 3 "2014-03-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Geo::StreetAddress::US \- Perl extension for parsing US street addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Geo::StreetAddress::US;
\&
\&  $hashref = Geo::StreetAddress::US\->parse_location(
\&                "1005 Gravenstein Hwy N, Sebastopol CA 95472" );
\&
\&  $hashref = Geo::StreetAddress::US\->parse_location(
\&                "Hollywood & Vine, Los Angeles, CA" );
\&
\&  $hashref = Geo::StreetAddress::US\->parse_address(
\&                "1600 Pennsylvania Ave, Washington, DC" );
\&
\&  $hashref = Geo::StreetAddress::US\->parse_address(
\&                "1600 Pennsylvania Ave, Washington, DC" );
\&
\&  $hashref = Geo::StreetAddress::US\->parse_informal_address(
\&                "Lot 3 Pennsylvania Ave" );
\&
\&  $hashref = Geo::StreetAddress::US\->parse_intersection(
\&                "Mission Street at Valencia Street, San Francisco, CA" );
\&
\&  $hashref = Geo::StreetAddress::US\->normalize_address( \e%spec );
\&      # the parse_* methods call this automatically...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Geo::StreetAddress::US is a regex-based street address and street intersection
parser for the United States. Its basic goal is to be as forgiving as possible
when parsing user-provided address strings. Geo::StreetAddress::US knows about
directional prefixes and suffixes, fractional building numbers, building units,
grid-based addresses (such as those used in parts of Utah), 5 and 9 digit \s-1ZIP\s0
codes, and all of the official \s-1USPS\s0 abbreviations for street types, state
names and secondary unit designators.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Most Geo::StreetAddress::US methods return a reference to a hash containing
address or intersection information. This
\&\*(L"address specifier\*(R" hash may contain any of the following fields for a
given address. If a given field is not present in the address, the
corresponding key will be set to \f(CW\*(C`undef\*(C'\fR in the hash.
.PP
Future versions of this module may add extra fields.
.SH "ADDRESS SPECIFIER"
.IX Header "ADDRESS SPECIFIER"
.SS "number"
.IX Subsection "number"
House or street number.
.SS "prefix"
.IX Subsection "prefix"
Directional prefix for the street, such as N, \s-1NE, E,\s0 etc.  A given prefix
should be one to two characters long.
.SS "street"
.IX Subsection "street"
Name of the street, without directional or type qualifiers.
.SS "type"
.IX Subsection "type"
Abbreviated street type, e.g. Rd, St, Ave, etc. See the \s-1USPS\s0 official
type abbreviations at <http://pe.usps.com/text/pub28/pub28apc.html>
for a list of abbreviations used.
.SS "suffix"
.IX Subsection "suffix"
Directional suffix for the street, as above.
.SS "city"
.IX Subsection "city"
Name of the city, town, or other locale that the address is situated in.
.SS "state"
.IX Subsection "state"
The state which the address is situated in, given as its two-letter
postal abbreviation.  for a list of abbreviations used.
.SS "zip"
.IX Subsection "zip"
Five digit \s-1ZIP\s0 postal code for the address, including leading zero, if needed.
.SS "sec_unit_type"
.IX Subsection "sec_unit_type"
If the address includes a Secondary Unit Designator, such as a room, suite or
appartment, the \f(CW\*(C`sec_unit_type\*(C'\fR field will indicate the type of unit.
.SS "sec_unit_num"
.IX Subsection "sec_unit_num"
If the address includes a Secondary Unit Designator, such as a room, suite or appartment,
the \f(CW\*(C`sec_unit_num\*(C'\fR field will indicate the number of the unit (which may not be numeric).
.SH "INTERSECTION SPECIFIER"
.IX Header "INTERSECTION SPECIFIER"
.SS "prefix1, prefix2"
.IX Subsection "prefix1, prefix2"
Directional prefixes for the streets in question.
.SS "street1, street2"
.IX Subsection "street1, street2"
Names of the streets in question.
.SS "type1, type2"
.IX Subsection "type1, type2"
Street types for the streets in question.
.SS "suffix1, suffix2"
.IX Subsection "suffix1, suffix2"
Directional suffixes for the streets in question.
.SS "city"
.IX Subsection "city"
City or locale containing the intersection, as above.
.SS "state"
.IX Subsection "state"
State abbreviation, as above.
.SS "zip"
.IX Subsection "zip"
Five digit \s-1ZIP\s0 code, as above.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
Geo::StreetAddress::US contains a number of global variables which it
uses to recognize different bits of \s-1US\s0 street addresses. Although you
will probably not need them, they are documented here for completeness's
sake.
.ie n .SS "%Directional"
.el .SS "\f(CW%Directional\fP"
.IX Subsection "%Directional"
Maps directional names (north, northeast, etc.) to abbreviations (N, \s-1NE,\s0 etc.).
.ie n .SS "%Direction_Code"
.el .SS "\f(CW%Direction_Code\fP"
.IX Subsection "%Direction_Code"
Maps directional abbreviations to directional names.
.ie n .SS "%Street_Type"
.el .SS "\f(CW%Street_Type\fP"
.IX Subsection "%Street_Type"
Maps lowercased \s-1USPS\s0 standard street types to their canonical postal
abbreviations as found in TIGER/Line.  See eg/get_street_abbrev.pl in
the distrbution for how this map was generated.
.ie n .SS "%State_Code"
.el .SS "\f(CW%State_Code\fP"
.IX Subsection "%State_Code"
Maps lowercased \s-1US\s0 state and territory names to their canonical two-letter
postal abbreviations. See eg/get_state_abbrev.pl in the distrbution
for how this map was generated.
.ie n .SS "%State_FIPS"
.el .SS "\f(CW%State_FIPS\fP"
.IX Subsection "%State_FIPS"
Maps two-digit \s-1FIPS\-55 US\s0 state and territory codes (including the
leading zero!) as found in TIGER/Line to the state's canonical two-letter
postal abbreviation. See eg/get_state_fips.pl in the distrbution for
how this map was generated. Yes, I know the \s-1FIPS\s0 data also has the state
names. Oops.
.ie n .SS "%Addr_Match"
.el .SS "\f(CW%Addr_Match\fP"
.IX Subsection "%Addr_Match"
A hash of compiled regular expressions corresponding to different
types of address or address portions. Defined regexen include
type, number, fraction, state, direct(ion), dircode, zip, corner,
street, place, address, and intersection.
.PP
Direct use of these patterns is not recommended because they may change in
subtle ways between releases.
.SH "CLASS ACCESSORS"
.IX Header "CLASS ACCESSORS"
.SS "avoid_redundant_street_type"
.IX Subsection "avoid_redundant_street_type"
If true then \*(L"normalize_address\*(R" will set the \f(CW\*(C`type\*(C'\fR field to undef
if the \f(CW\*(C`street\*(C'\fR field contains a word that corresponds to the \f(CW\*(C`type\*(C'\fR in \e%Street_Type.
.PP
For example, given \*(L"4321 Country Road 7\*(R", \f(CW\*(C`street\*(C'\fR will be \*(L"Country Road 7\*(R"
and \f(CW\*(C`type\*(C'\fR will be \*(L"Rd\*(R". With avoid_redundant_street_type set true, \f(CW\*(C`type\*(C'\fR
will be undef because \f(CW\*(C`street\*(C'\fR matches /\eb (rd|road) \eb/ix;
.PP
Also applies to \f(CW\*(C`type1\*(C'\fR for \f(CW\*(C`street1\*(C'\fR and \f(CW\*(C`type2\*(C'\fR for \f(CW\*(C`street2\*(C'\fR
fields for intersections.
.PP
The default is false, for backwards compatibility.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "init"
.IX Subsection "init"
.Vb 4
\&    # Add another street type mapping:
\&    $Geo::StreetAddress::US::Street_Type{\*(Aqcur\*(Aq}=\*(Aqcurv\*(Aq;
\&    # Re\-initialize to pick up the change
\&    Geo::StreetAddress::US::init();
.Ve
.PP
Runs the setup on globals.  This is run automatically when the module is loaded,
but if you subsequently change the globals, you should run it again.
.SS "parse_location"
.IX Subsection "parse_location"
.Vb 1
\&    $spec = Geo::StreetAddress::US\->parse_location( $string )
.Ve
.PP
Parses any address or intersection string and returns the appropriate
specifier. If \f(CW$string\fR matches the \f(CW$Addr_Match\fR{corner} pattern then
\&\fIparse_intersection()\fR is used.  Else \fIparse_address()\fR is called and if that
returns false then \fIparse_informal_address()\fR is called.
.SS "parse_address"
.IX Subsection "parse_address"
.Vb 1
\&    $spec = Geo::StreetAddress::US\->parse_address( $address_string )
.Ve
.PP
Parses a street address into an address specifier using the \f(CW$Addr_Match\fR{address}
pattern. Returning undef if the address cannot be parsed as a complete formal
address.
.PP
You may want to use \fIparse_location()\fR instead.
.SS "parse_informal_address"
.IX Subsection "parse_informal_address"
.Vb 1
\&    $spec = Geo::StreetAddress::US\->parse_informal_address( $address_string )
.Ve
.PP
Acts like \fIparse_address()\fR except that it handles a wider range of address
formats because it uses the \*(L"informal_address\*(R" pattern. That means a
unit can come first, a street number is optional, and the city and state aren't
needed. Which means that informal addresses like \*(L"#42 123 Main St\*(R" can be parsed.
.PP
Returns undef if the address cannot be parsed.
.PP
You may want to use \fIparse_location()\fR instead.
.SS "parse_intersection"
.IX Subsection "parse_intersection"
.Vb 1
\&    $spec = Geo::StreetAddress::US\->parse_intersection( $intersection_string )
.Ve
.PP
Parses an intersection string into an intersection specifier, returning
undef if the address cannot be parsed. You probably want to use
\&\fIparse_location()\fR instead.
.SS "normalize_address"
.IX Subsection "normalize_address"
.Vb 1
\&    $spec = Geo::StreetAddress::US\->normalize_address( $spec )
.Ve
.PP
Takes an address or intersection specifier, and normalizes its components,
stripping out all leading and trailing whitespace and punctuation, and
substituting official abbreviations for prefix, suffix, type, and state values.
Also, city names that are prefixed with a directional abbreviation (e.g. N, \s-1NE,\s0
etc.) have the abbreviation expanded.  The original specifier ref is returned.
.PP
Typically, you won't need to use this method, as the \f(CW\*(C`parse_*()\*(C'\fR methods
call it for you.
.PP
N.B., \f(CW\*(C`normalize_address()\*(C'\fR crops 9\-digit \s-1ZIP\s0 codes to 5 digits. This is for
the benefit of Geo::Coder::US and may not be what you want. E\-mail me if this
is a problem and I'll see what I can do to fix it.
.SH "BUGS, CAVEATS, MISCELLANY"
.IX Header "BUGS, CAVEATS, MISCELLANY"
Geo::StreetAddress::US might not correctly parse house numbers that contain
hyphens, such as those used in parts of Queens, New York. Also, some addresses
in rural Michigan and Illinois may contain letter prefixes to the building
number that may cause problems. Fixing these edge cases is on the to-do list,
to be sure. Patches welcome!
.PP
This software was originally part of Geo::Coder::US (q.v.) but was split apart
into an independent module for your convenience. Therefore it has some
behaviors which were designed for Geo::Coder::US, but which may not be right
for your purposes. If this turns out to be the case, please let me know.
.PP
Geo::StreetAddress::US does \fB\s-1NOT\s0\fR perform USPS-certified address normalization.
.PP
Grid based addresses, like those in Utah, where the direction comes before the
number, e.g. W164N5108 instead of 164 W 5108 N, aren't handled at the moment.
A workaround is to apply a regex like this
.PP
.Vb 1
\&    s/([nsew])\es*(\ed+)\es*([nsew])\es*(\ed+)/$2 $1 $4 $3/
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This software was originally part of \fIGeo::Coder::US\fR\|(3pm).
.PP
\&\fILingua::EN::AddressParse\fR\|(3pm) and \fIGeo::PostalAddress\fR\|(3pm) both do something
very similar to Geo::StreetAddress::US, but are either too strict/limited in
their address parsing, or not really specific enough in how they break down
addresses (for my purposes). If you want USPS-style address standardization,
try \fIScrape::USPS::ZipLookup\fR\|(3pm). Be aware, however, that it scrapes a form on
the \s-1USPS\s0 website in a way that may not be officially permitted and might break
at any time. If this module does not do what you want, you might give the
othersa try. All three modules are available from the \s-1CPAN.\s0
.PP
You can see Geo::StreetAddress::US in action at <http://geocoder.us/>.
.PP
\&\s-1USPS\s0 Postal Addressing Standards: <http://pe.usps.com/text/pub28/welcome.htm>
.SH "APPRECIATION"
.IX Header "APPRECIATION"
Many thanks to Dave Rolsky for submitting a very useful patch to fix fractional
house numbers, dotted directionals, and other kinds of edge cases, e.g. South
St. He even submitted additional tests!
.SH "AUTHOR"
.IX Header "AUTHOR"
Schuyler D. Erle <schuyler@geocoder.us>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 by Schuyler D. Erle.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
